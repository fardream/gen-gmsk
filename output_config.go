package main

import (
	"embed"
	"fmt"
	"io"
	"log"
	"strings"

	"github.com/goccy/go-yaml"
)

//go:embed config.yml
var configJson embed.FS

type EnumConfig struct {
	GoName           string            `json:"go_name"`
	Skip             bool              `json:"skip"`
	Comments         string            `json:"comment"`
	ConstantComments map[string]string `json:"constant_comments"`
	IntegerType      string            `json:"integer_type"`
	IsEqualType      bool              `json:"is_equal_type"`
}

type OutputConfig struct {
	Enums map[string]*EnumConfig `json:"enums"`

	PackageName string `json:"package_name"`
}

func NewOutputConfig() *OutputConfig {
	data, err := configJson.ReadFile("config.yml")
	if err != nil {
		log.Panic(err)
	}

	r := &OutputConfig{
		Enums:       make(map[string]*EnumConfig),
		PackageName: "gmsk",
	}

	err = yaml.Unmarshal(data, r)
	if err != nil {
		log.Panic(err)
	}

	return r
}

func BuildSource(h *MosekH, config *OutputConfig, out io.Writer) error {
	fmt.Println("// Automatically generated by github.com/fardream/gen-gmsk\n// Don't edit by hand")
	fmt.Printf("package %s\n", config.PackageName)

	return nil
}

func GetGoName(name string) string {
	if strings.HasPrefix(name, "MSK_") {
		return strings.TrimPrefix(name, "MSK_")
	} else if strings.HasPrefix(name, "MSK") {
		return strings.TrimPrefix(name, "MSK")
	}

	return name
}

func SplitComments(out io.Writer, s string) {
	if s == "" {
		return
	}
	for _, v := range strings.Split(s, "\n") {
		fmt.Fprintf(out, "// %s\n", v)
	}
}

func GetEnumType(underlying string) string {
	switch underlying {
	case "int":
		return "int32"
	case "unsigned int":
		fallthrough
	default:
		return "uint32"
	}
}

func UpperCaseFirstLetter(s string) string {
	b := []byte(s)
	if len(b) == 0 {
		return s
	}
	if b[0] >= 'a' && b[0] <= 'z' {
		b[0] -= byte('a') - byte('A')
	}

	return string(b)
}

func Normalize(h *MosekH, config *OutputConfig) error {
	if config.Enums == nil {
		config.Enums = map[string]*EnumConfig{}
	}
	for _, enumName := range h.EnumList {
		v, ok := h.Enums[enumName]
		if !ok {
			return fmt.Errorf("enum %s is not found in parsed mosek.h", enumName)
		}
		enumConfig, found := config.Enums[enumName]
		if !found {
			goName := UpperCaseFirstLetter(strings.TrimSuffix(GetGoName(enumName), "_enum"))
			enumConfig = &EnumConfig{GoName: goName, Skip: false}
			config.Enums[enumName] = enumConfig
		}
		if enumConfig.ConstantComments == nil {
			enumConfig.ConstantComments = make(map[string]string)
		}
		if enumConfig.IntegerType == "" {
			enumConfig.IntegerType = GetEnumType(v.IntegerType)
		}
	}

	return nil
}

func BuildEnums(h *MosekH, config *OutputConfig, out io.Writer) error {
	fmt.Fprintln(out, "// Automatically generated by github.com/fardream/gen-gmsk")
	fmt.Fprintln(out, "// There are many enums in MOSEK, this consolidate everything here.")
	fmt.Fprintln(out)
	fmt.Fprintf(out, "package %s\n", config.PackageName)

	for _, enumName := range h.EnumList {
		if enumName == "MSKrescode_enum" {
			continue
		}
		fmt.Fprintln(out)

		enumData, ok := h.Enums[enumName]
		if !ok {
			return fmt.Errorf("enum %s is not found in parsed mosek.h", enumName)
		}
		enumConfig, found := config.Enums[enumName]
		if !found {
			log.Panicf("failed to find confing for enum: %s", enumName)
		}
		if enumConfig.Skip {
			continue
		}
		if enumConfig.ConstantComments == nil {
			enumConfig.ConstantComments = make(map[string]string)
		}
		fmt.Fprintf(out, "// %s is %s\n//\n", enumConfig.GoName, enumName)
		SplitComments(out, enumConfig.Comments)
		equalstr := " "
		if enumConfig.IsEqualType {
			equalstr = " = "
		}
		fmt.Fprintf(out, "type %s%s%s\n", enumConfig.GoName, equalstr, enumConfig.IntegerType)
		if len(enumData.Values) == 0 {
			continue
		}

		fmt.Fprintln(out, "const (")
		for _, enumValue := range enumData.Values {
			valueComment := ""
			if enumConfig.ConstantComments != nil {
				v, found := enumConfig.ConstantComments[enumValue.Name]
				if found {
					valueComment = fmt.Sprintf("// %s", v)
				}
			}
			fmt.Fprintf(out, "\t%s %s = %s%s\n", GetGoName(enumValue.Name), enumConfig.GoName, enumValue.Value, valueComment)
		}
		fmt.Fprintln(out, ")")
	}

	return nil
}

func BuildResCode(h *MosekH, config *OutputConfig, out io.Writer) error {
	rescodeEnum, ok := h.Enums["MSKrescode_enum"]
	if !ok {
		return fmt.Errorf("failed to find MSKrescode_enum from parsed mosek header")
	}

	fmt.Fprintln(out, "// Automatically generated by github.com/fardream/gen-gmsk")
	fmt.Fprintln(out, "// response codes")
	fmt.Fprintln(out)
	fmt.Fprintln(out, "package res")

	fmt.Fprintln(out, "const (")
	for _, v := range rescodeEnum.Values {
		fmt.Fprintf(out, "\t%s Code = %s\n", strings.TrimPrefix(v.Name, "MSK_RES_"), v.Value)
	}
	fmt.Fprintln(out, ")")

	fmt.Fprintln(out, "var resCodeMsg map[Code]string = make(map[Code]string)")
	fmt.Fprintln(out)
	fmt.Fprintln(out, "func init() {")
	for _, v := range rescodeEnum.Values {
		fmt.Fprintf(out, "resCodeMsg[%s] = \"%s (%s)\"\n", strings.TrimPrefix(v.Name, "MSK_RES_"), v.Name, v.Value)
	}
	fmt.Fprintln(out, "}")

	return nil
}
